<!DOCTYPE html>
<script src='../resources/testharness.js'></script>
<script src='../resources/testharnessreport.js'></script>
<script>
var t1 = async_test('Reading twice on a stream that gets closed');
t1.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });
    var counter = 0;
    var reader = rs.getReader();

    reader.read().then(t1.step_func(function(result) {
        assert_object_equals(result, { value: undefined, done: true }, 'read() should fulfill with close');
        assert_equals(counter, 1);
        counter++;
    }));
    reader.read().then(t1.step_func(function(result) {
        assert_object_equals(result, { value: undefined, done: true }, 'read() should fulfill with close');
        assert_equals(counter, 2);
        counter++;
        t1.done();
    }));
    reader.closed.then(t1.step_func(function() {
        assert_equals(counter, 0);
        counter++;
    }));

    controller.close();
});

var t2 = async_test('Reading twice on a closed stream');
t2.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

    controller.close();

    var counter = 0;
    var reader = rs.getReader();

    reader.read().then(t2.step_func(function(result) {
        assert_object_equals(result, { value: undefined, done: true }, 'read() should fulfill with close');
        assert_equals(counter, 0);
        counter++;
    }));
    reader.read().then(t2.step_func(function(result) {
        assert_object_equals(result, { value: undefined, done: true }, 'read() should fulfill with close');
        assert_equals(counter, 1);
        counter++;
    }));
    reader.closed.then(t2.step_func(function() {
        assert_equals(counter, 2);
        counter++;
        t2.done();
    }));
});

var t3 = async_test('Reading twice on an errored stream');
t3.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

    var myError = { potato: "mashed" };
    controller.error(myError);

    var counter = 0;
    var reader = rs.getReader();

    reader.read().then(t3.step_func(function() {
        assert_unreached('read() should reject on an errored stream');
    }), t3.step_func(function(err) {
        assert_equals(myError, err);
        assert_equals(counter, 0);
        counter++;
    }));
    reader.read().then(t3.step_func(function() {
        assert_unreached('read() should reject on an errored stream');
    }), t3.step_func(function(err) {
        assert_equals(myError, err);
        assert_equals(counter, 1);
        counter++;
    }));
    reader.closed.then(t3.step_func(function() {
        assert_unreached('read() should reject on an errored stream');
    }), t3.step_func(function(err) {
        assert_equals(myError, err);
        assert_equals(counter, 2);
        counter++;
        t3.done();
    }));
});

var t4 = async_test('Reading twice on a stream that gets errored');
t4.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

    var counter = 0;
    var reader = rs.getReader();

    reader.read().then(t4.step_func(function() {
        assert_unreached('read() should reject on an errored stream');
    }), t4.step_func(function(err) {
        assert_equals(myError, err);
        assert_equals(counter, 1);
        counter++;
    }));
    reader.read().then(t4.step_func(function() {
        assert_unreached('read() should reject on an errored stream');
    }), t4.step_func(function(err) {
        assert_equals(myError, err);
        assert_equals(counter, 2);
        counter++;
        t4.done();
    }));
    reader.closed.then(t4.step_func(function() {
        assert_unreached('read() should reject on an errored stream');
    }), t4.step_func(function(err) {
        assert_equals(myError, err);
        assert_equals(counter, 0);
        counter++;
    }));

    var myError = { potato: 'mashed' };
    controller.error(myError);
 });

var t5 = async_test('Reading within a read promise resolve callback on a stream that gets closed');
t5.step(function() {
    var controller;
    var rs = new ReadableStream({
        start: function(c) {
            controller = c;
        }
    });

    var reader = rs.getReader();

    reader.read().then(t5.step_func(function() {
        reader.read().then(t5.step_func(function() {
            t5.done();
        }));
    }));
    controller.close();
});
</script>
